# 设计模式-可复用面向对象软件的基础

## 推荐网站
    https://refactoring.guru/design-patterns

## 设计模式基础
### 1.什么是设计模式
#### 1.1 模式四要素
    模式名称        pattern name
    问题           problem
    解决方案        solution
    效果           consequences
    
### 2.怎样选择设计模式
#### 考虑设计模式是怎样解决设计问题的
#### 浏览模式的意图（intent）部分    
#### 研究模式怎样相互关联    
#### 研究目的相似的模式    
#### 检查重新设计的原因
    通过显式地指定一个类来创建对象
    对特殊操作的依赖
    对硬件和软件平台的依赖
    对对象表示或实现的依赖
    算法依赖
    紧耦合
    通过生成子类来扩展功能
    不能方便的对类进行修改   
        
## 设计模式编目

### 创建型Creational
    与对象的创建有关
### 结构型
    处理类或对象的组合
### 行为型
    对类或对象怎样交互和怎样分配职责进行描述
### 类模式
    处理类和子类之间的关系。这些关系通过继承建立，是静态的，在编译时刻便确定下来了
### 对象模式
    处理对象间的关系   
 
=================================================================      
  
  
=================================================================
  
### Abstract Factory 抽象工厂  --对象创建型模式

    提供创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。
#### 意图
    提供一个创建一系列相关的或者相互依赖对象的接口,而无需指定它们具体的类.
#### 适用性
    1.一个系统要独立于它的产品的创建\组合和表示时.
    2.一个系统要由多个产品系列中的一个来配置时.
    3.当你要强调一系列相关的产品对象的设计以便进行联合使用时.
    4.当你提供一个产品类库,而只想显示它们的接口而不是实现时.
    
    
#### 意图
    提供创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。
    
#### 别名
    Kit、Abstract Factory
    
#### 适用场景
##### 1.如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。
##### 2.如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。


#### 参与者

##### 1.抽象产品 （Abstract Product） 
    为构成系列产品的一组不同但相关的产品声明接口。
    
##### 2.具体产品 （Concrete Product）  
    是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。
    
##### 3.抽象工厂 （Abstract Factory）
    接口声明了一组创建各种抽象产品的方法。
    
##### 4.具体工厂 （Concrete Factory） 
    实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体
    
##### 5.客户端 （Client）
    仅使用由抽象工厂和抽象产品类声明的接口。客户端 （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。
    
#### 协作
#### 实现
#### 优缺点
##### 1.优点
    你可以确保同一工厂生成的产品相互匹配。
    你可以避免客户端和具体产品代码的耦合。
    单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
    开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。
##### 2.缺点
    由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。
#### 源码示例

     javax.xml.parsers.DocumentBuilderFactory#newInstance()
    
     javax.xml.transform.TransformerFactory#newInstance()
    
     javax.xml.xpath.XPathFactory#newInstance()

    
=================================================================        

   
================================================================= 
### Adapter 适配器模式， 别名包装器 Wrapper   --类对象结构型模式  
    将一个类的接口转成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    转换匹配，复用功能
#### 结构
    Client
        客户端，调用自己需要的领域接口Target。
    Target
        定义客户端需要的跟特定领域相关的接口。
    Adaptee
        已经存在的接口，通常能满足客户端的需求，但是接口与客户端要求的特定领域接口不一致，需要被适配。
    Adapter
        适配器。把Adaptee适配成Client需要Target。
#### 实现
##### 类适配器
    这一实现使用了继承机制： 适配器同时继承两个对象的接口。 请注意， 
    这种方式仅能在支持多重继承的编程语言中实现， 例如 C++。
    类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 
    最后生成的适配器可替代已有的客户端类进行使用。
##### 对象适配器
    实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 
    所有流行的编程语言都可以实现适配器。
#### 适用场景
    1.当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。
      适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。
    2.如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 
    但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。
    
#### 源码示例
    There are some standard Adapters in Java core libraries:
    
    java.util.Arrays#asList()
    java.util.Collections#list()
    java.util.Collections#enumeration()
    java.io.InputStreamReader(InputStream) (returns a Reader object)
    java.io.OutputStreamWriter(OutputStream) (returns a Writer object)
    javax.xml.bind.annotation.adapters.XmlAdapter#marshal() and #unmarshal()

   
=================================================================    
    
    
=================================================================
### Bridge --对象结构型模式  --单一职责模式

    将抽象部分与它的实现部分分离，使它们都可以独立地变化。
    
    桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。
    
    桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 
    这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。
    
#### 意图
    将抽象部分与它的实现部分分离，使它们都可以独立地变化。
#### 别名 
    Handle / Body
#### 适用场景
##### 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。
    类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 
    一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。
    
    桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 
    这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。
##### 如果你希望在几个独立维度上扩展一个类， 可使用该模式。
    桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。
##### 如果你需要在运行时切换不同实现方法， 可使用桥接模式。
    当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。
    
    顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。 
    
#### 参与者

    GOF经典定义： Abstraction、RefinedAbstraction、Implementor、ConcreteImplementor 

##### 1. Abstraction
    抽象部分 （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。
##### 2.Implementation
    实现部分 （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。
    
    抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。
    
##### 3.Concrete Implementations
    具体实现 （Concrete Implementations） 中包括特定于平台的代码。
    
##### 4.Refined Abstraction  可选的
    精确抽象 （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。
    
##### 5.Client
    通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。
    
#### 协作
    Abstraction将client的请求转发给它的Implementor。
    
#### 实现
    1.明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。

    2.了解客户端的业务需求， 并在抽象基类中定义它们。

    3.确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。

    4.为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。

    5.在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。

    6.如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。

    7.客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。

#### 优缺点
##### 1.优点
    你可以创建与平台无关的类和程序
    客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。
    开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。
    单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。
##### 2.缺点
    对高内聚的类使用该模式可能会让代码更加复杂。

#### 与其他模式的关系
    桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。

    桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

    你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

    你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。    
    

#### 源码示例 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用。


#### 识别方法
    桥接可以通过一些控制实体及其所依赖的多个不同平台之间的明确区别来进行识别。
  
=================================================================    
    
    
=================================================================
### Builder 
#### 意图
    将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。
#### 源码举例
        Builder is widely used in Java core libraries:
        
        java.lang.StringBuilder#append() (unsynchronized)
        java.lang.StringBuffer#append() (synchronized)
        java.nio.ByteBuffer#put() (also in CharBuffer, ShortBuffer, IntBuffer, LongBuffer,  FloatBuffer and DoubleBuffer)
        javax.swing.GroupLayout.Group#addComponent()
        All implementations java.lang.Appendable
  
=================================================================    
    
    
=================================================================
### Chain of Responsibility  
    为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例  
=================================================================   
     
     
=================================================================
### Command 
    将一个请求封装为一个对象，从而是你可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例   
=================================================================  
      
      
=================================================================  
### Decorator    --对象结构型模式
    动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
#### 意图
    动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
#### 别名
    包装器Wrapper
#### 适用场景
    如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。
    处理那些可以撤销的职责。
    如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。
#### 参与者
##### 1.部件 （Component） 
    声明封装器和被封装对象的公用接口。
    
##### 2.具体部件 （Concrete Component）  
    是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。
    
##### 3.基础装饰  （Base Decorator）
    拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 
    这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。
    
##### 4.具体装饰类 （Concrete Decorators） 
    定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。
    
##### 5.客户端 （Client）
    可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。
    
#### 协作
#### 实现

##### 1.确保业务逻辑可用一个基本组件及多个额外可选层次表示。

##### 2.找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。

##### 3.创建一个具体组件类， 并定义其基础行为。

##### 4.创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。

##### 5.确保所有类实现组件接口。

##### 6.将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。

##### 7.客户端代码负责创建装饰并将其组合成客户端所需的形式。

    多个装饰器装饰函数时,离函数近的装饰器先进行装饰，下面的装饰器先装饰完后将整个装饰结果给第一个装饰器进行装饰.
    即：封装时自内而外(自下而上)，执行时自外而内(自上而下)
#### 优缺点
##### 1.优点
    你无需创建新子类即可扩展对象的行为。
    你可以在运行时添加或删除对象的功能。
    你可以用多个装饰封装对象来组合几种行为。
    单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。
##### 2.缺点
    在封装器栈中删除特定封装器比较困难。
    实现行为不受装饰栈顺序影响的装饰比较困难。
    各层的初始化配置代码看上去可能会很糟糕。
#### 源码示例   
    装饰在 Java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。
    java.io.InputStream、  Output­Stream、  Reader 和  Writer 的所有代码都有以自身类型的对象作为参数的构造函数。
    java.util.Collections；  checked­XXX()、  synchronized­XXX() 和  unmodifiable­XXX() 
    javax.servlet.http.HttpServletRequestWrapper 和  Http­Servlet­Response­Wrapper
#### 识别方法
    装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。
    
================================================================= 
      
      
=================================================================
### Facade  --对象结构型模式
    为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
   
#### 意图
    为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
#### 别名
#### 适用场景
     GOF： 同时满足以下条件时使用Facade模式
     在遇到以下情况使用Facade模式
     1. 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。
     大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。
     Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 Facade层。
     2.客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。
     3.当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。
     
     
     1.如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。
       子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 
       为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。
       
     2.如果需要将子系统组织为多层结构， 可以使用外观。
       创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。
     
#### 参与者 
    https://refactoringguru.cn/design-patterns/facade， 和GOF模式的参与者不同。
    GOF经典模式中，Facade模式的角色包括：Facade 、 Subsystem Classes。
        
##### 1.Facade
    外观 （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。
##### 2.Additional Facade
    创建附加外观 （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
##### 3.Complex Subsystem
    复杂子系统 （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。
    
    子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。
##### 4.Client
    客户端 （Client） 使用外观代替对子系统对象的直接调用。
    
#### 协作

#### 实现
    1.考虑能否在现有子系统的基础上提供一个更简单的接口。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。
    
    2.在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。
    
    3.如果要充分发挥这一模式的优势， 你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。
    
    4.如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。。
#### 优缺点
##### 1.优点
    你可以让自己的代码独立于复杂子系统
##### 2.缺点
    你可外观可能成为与程序中所有类都耦合的上帝对象。
#### 源码示例  
    javax.faces.context.FacesContext 在底层使用了 Life­Cycle、 View­Handler 和 Navigation­Handler 这几个类， 但绝大多数客户端不知道。
    
    javax.faces.context.ExternalContext 在内部使用了 Servlet­Context、 Http­Session、 Http­Servlet­Request、 Http­Servlet­Response 和其他一些类。
    
#### 识别方法
    外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期。
    
#### 与其他模式的关系
    1.外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。
    2.当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂模式来代替外观。
    3.享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。
    4.外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
            外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。
            中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。
    5.外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。
    6.外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 
      代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。
   
=================================================================
        
        
=================================================================   
### Factory Method  ==== 对象创建型模式
    定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到了其子类。
#### 意图（intent)或者动机（motivation）
    Factory method is a creational design pattern which solves the problem of creating product objects 
    without specifying their concrete classes.
    工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
#### 参与者
##### 1.Product
    产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
##### 2.ConcreteProduct
    具体产品 （Concrete Products） 是产品接口的不同实现。
##### 3.Creator
    创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。
    
    你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。
    
    注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 
    工厂方法将这些逻辑处理从具体产品类中分离出来。
     打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。
##### 4.ConcreteCreator
    具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。
    
    注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。

#### 应用场景
    1.当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。
         工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。
    2.如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。
    3.如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。
#### 如何实现
    1.Make all products follow the same interface. This interface should declare methods that make sense in every product.
    
    2.Add an empty factory method inside the creator class. The return type of the method should match the common product interface.
    
    3.In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, 
    while extracting the product creation code into the factory method.
    
        You might need to add a temporary parameter to the factory method to control the type of returned product.
    
        At this point, the code of the factory method may look pretty ugly. It may have a large switch operator 
        that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.
    
    4.Now, create a set of creator subclasses for each type of product listed in the factory method. 
        Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.
    
    5.If there are too many product types and it doesn’t make sense to create subclasses for all of them, 
        you can reuse the control parameter from the base class in subclasses.
      
      For instance, imagine that you have the following hierarchy of classes: the base Mail class with a couple of subclasses: 
      AirMail and GroundMail; the Transport classes are Plane, Truck and Train. While the AirMail class only uses Plane objects, 
      GroundMail may work with both Truck and Train objects. You can create a new subclass (say TrainMail) to handle both cases, 
      but there’s another option. The client code can pass an argument to the factory method of the GroundMail class to control which product it wants to receive.
      
    6.If, after all of the extractions, the base factory method has become empty, you can make it abstract. 
        If there’s something left, you can make it a default behavior of the method.
#### Pros and Cons
##### 1.优点
    1.你可以避免创建者和具体产品之间的紧密耦合。
    2.单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
    3.开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型
    
##### 2.缺点
    应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。
    
#### 源码举例
    java.util.Calendar#getInstance()
    java.util.ResourceBundle#getBundle()
    java.text.NumberFormat#getInstance()
    java.nio.charset.Charset#forName()
    java.util.EnumSet#of()   
    
     
  
=================================================================   
     
     
=================================================================
### Simple factory pattern 

    并不算一个严格的设计模式。
    简单工厂模式描述了一个具有一个创建方法和一个大型条件的类，该条件基于方法参数选择实例化哪个产品类并返回。
    本质-->选择实现！ 负责创建接口对象。 选择合适的实现类来创建接口的对象。
   
=================================================================    
    
    
=================================================================  
### Flyweight --对象结构型模式  --对象性能模式
    运用共享技术有效地支持大量细粒度的对象。  
#### 意图
    运用共享技术有效地支持大量细粒度的对象。
    
    享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。 
    这些对象的区别仅在于其内在状态 （与外在状态相比， 内在状态的变体要少很多）， 因此你所需的对象数量会大大削减。
#### 别名


#### 享元与不可变性
##### 内部状态
    内部状态存储在flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享。
##### 外部状态
    外部状态取决于flyweight场景，并根据场景而变化，因此不可以共享。
    用户对象负责在必要的时候将外部状态传递给flyweight。
##### 不可变性 自满足
    由于享元对象可在不同的情景中使用， 你必须确保其状态不能被修改。 
    享元类的状态只能由构造函数的参数进行一次性初始化， 它不能对其他对象公开其设置器或公有成员变量。
#### 适用场景
     GOF： 同时满足以下条件时使用flyweight模式
     1.一个应用程序使用了大量的对象
     2.完全由于使用大量的对象，造成很大的内存开销
     3.对象的大多数状态都可变为外部状态
     4.如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象
     5.应用程序不依赖于对象标识

     仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。
     
     应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：
         程序需要生成数量巨大的相似对象
         这将耗尽目标设备的所有内存
         对象中包含可抽取且能在多个对象间共享的重复状态。
         
     
     享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。
     
     享元模式只有一个目的： 将内存消耗最小化。 如果你的程序没有遇到内存容量不足的问题， 则可以暂时忽略该模式。
     
#### 参与者 
    https://refactoringguru.cn/design-patterns/flyweight， 和GOF模式的参与者不同。
    GOF经典模式中，享元模式的角色包括：Flyweight 、 ConcreteFlyweight、UnsharedConcreteFlyweight、FlyweightFactory、Client。
        
##### 1.Flyweight
    享元 （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。
    享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。
##### 2.Context
    情景 （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。
     
    通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。
    
##### 3.Client
    客户端 （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。
##### 4.Flyweight Factory
    享元工厂 （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 
    工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。

#### 协作

#### 实现
    1.将需要改写为享元的类成员变量拆分为两个部分：
    
        内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。
        外在状态： 包含每个对象各自不同的情景数据的成员变量
    
    2.保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。
    
    3.找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。
    
    4.你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。
    
    5.客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。
#### 优缺点
##### 1.优点
    如果程序中有很多相似对象， 那么你将可以节省大量内存。
##### 2.缺点
    你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。
    
    代码会变得更加复杂。 团队中的新成员总是会问： ​ “为什么要像这样拆分一个实体的状态？”。
#### 源码示例  
    java.lang.Integer#valueOf(int) （以及  Boolean、  Byte、  Character、 Short、  Long 和  Big­Decimal）
    
#### 识别方法
    享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象。
    
#### 与其他模式的关系
    1.你可以使用享元模式实现组合模式树的共享叶节点以节省内存。
    2.享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。
    3.如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。
      只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。
      单例对象可以是可变的。 享元对象是不可变的。
        
=================================================================   
     
     
=================================================================
### Interpreter
    给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例 
=================================================================  
     
     
=================================================================
### Iterator
    提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例   
=================================================================    
    
    
=================================================================  

### Mediator
    用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而时期耦合松散，而且可以独立改变它们之间的交互。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例  
=================================================================   
     
     
=================================================================
### Memento
    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后以后就可以将该对象恢复到保存的状态。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例 
=================================================================    
    
    
=================================================================
### Observer
    定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例  
=================================================================   
     
     
=================================================================
### Prototype  Also known as: Clone
    用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
#### Intent 
    Prototype is a creational design pattern that lets you copy existing objects 
    without making your code dependent on their classes.
        
    
    原型模式将克隆过程委托给正在被克隆的实际对象。该模式为所有支持克隆的对象声明了一个公共接口。
    该接口允许您克隆对象，而无需将代码耦合到该对象的类。通常，这样的接口只包含一个克隆方法。

#### Structure
    1.Prototype
        Prototype接口声明了克隆方法。在大多数情况下，这是一个单一的克隆方法。
    2.ConcretePrototype
        具体的原型类实现了克隆方法。除了将原始对象的数据复制到克隆对象之外，该方法还可以处理
        克隆过程中与克隆链接对象相关的一些边缘情况，解缠递归依赖关系等。
    3.Client
        客户端可以生成遵循prototype接口的任何对象的副本
  
=================================================================    
    
    
=================================================================
### Proxy -- 对象结构型模式

    为其他对象提供一个代理以控制对这个对象的访问。
    
#### 意图
    为其他对象提供一个代理以控制对这个对象的访问。
    代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。
    
    代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。
#### 别名
    surrogate
#### 适用场景
##### 1.延迟初始化 （虚拟代理）。 
    如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。
    
    你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。
##### 2.访问控制 （保护代理）。 
    如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。
    
    代理可仅在客户端凭据满足要求时将请求传递给服务对象。
##### 3.本地执行远程服务 （远程代理）。 
    适用于服务对象位于远程服务器上的情形。
    
    在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。
##### 4.记录日志请求 （日志记录代理）。
    适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。
    
##### 5.缓存请求结果 （缓存代理）。
    适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。
    
    代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。
    
##### 6.智能引用 。
    可在没有客户端使用某个重量级对象时立即销毁该对象。
    
    代理会将所有获取了指向服务对象或其结果的客户端记录在案。 
    代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 
    如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。
    代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。
    
#### 参与者
##### 1.Service Interface
    服务接口 （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。
##### 2.Service
    服务 （Service） 类提供了一些实用的业务逻辑。。
##### 3.Proxy
    代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 
    代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。
    通常情况下， 代理会对其服务对象的整个生命周期进行管理。
##### 4.Client
    客户端 （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。
#### 协作
#### 实现
#### 优缺点
##### 1.优点
    你可以在客户端毫无察觉的情况下控制服务对象。
    如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。
    即使服务对象还未准备好或不存在， 代理也可以正常工作。
    开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。
##### 2.缺点
    代码可能会变得复杂， 因为需要新建许多类。
    服务响应可能会延迟。
#### 与其他模式的关系
    适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。
    
    外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。
    
    装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。
#### 源码示例 
     Java 标准程序库中的一些代理模式的示例：
     
      java.lang.reflect.Proxy
      java.rmi.*
      javax.ejb.EJB （查看评论）
      javax.inject.Inject （查看评论）
      javax.persistence.PersistenceContext
#### 识别方法
    代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。
    
    
=================================================================   
     
     
=================================================================
### Singleton
#### 定义
    
    保证一个类仅有一个实例，并提供一个访问它的全局访问点。
#### 四大原则
    1.构造私有器。
    2.以静态方法或者枚举返回实例。
    3.确保实例只有一个，尤其是多线程环境。
    4.确保反序列换时不会重新构建对象。
#### 最佳实践
    推荐枚举、 饿汉式（单线程环境）、双重检查锁、静态内部类方式实现单例模式。
    利用枚举来实现单例模式是最佳实践！！！ 还能防止反序列化重新创建新的对象！
#### 使用场景
    单例模式保证了系统内存中只存在一个对象，节省了系统资源。
    对于一些需要频繁创建或销毁的对象，使用单例模式可以提供系统性能。
    
    当实例化一个单例类的对象，必须记住要使用相应的获取对象的方法，而不是会用new关键字。
    
    需要频繁创建和销毁的对象、创建对象耗时过多或者耗费资源过多（即：重量级对象），
    但又经常用到的对象、工具类对象、频繁访问数据库或者文件的对象（比如数据源、session工厂等）。

#### 源码举例
    JDK java.lang.Runtime就是经典的用饿汉式实现的单例模式。
#### 深度阅读
    https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/
  
=================================================================  
      
      
=================================================================
### State
    允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例  
=================================================================       
     
     
=================================================================
### Strategy
    定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法的变化可以独立于使用它的客户。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例  
=================================================================    
        
        
=================================================================
### Template Method
    定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例 
=================================================================       
     
     
=================================================================
### Visitor
    表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

#### 意图
#### 别名
#### 适用场景
#### 参与者
#### 协作
#### 实现
#### 优缺点
##### 1.优点
##### 2.缺点
#### 源码示例  


    
=================================================================       
     
     
=================================================================
## 工厂模式比较
    https://refactoring.guru/design-patterns/factory-comparison
### 1.工厂

    工厂是一个含义模糊的术语， 表示可以创建一些东西的函数、 方法或类。 最常见的情况下， 工厂创建的是对象。 但是它们也可以创建文件和数据库记录等其他东西。
   
    例如， 下面这些东西都可以非正式地被称为 “工厂”：
   
    创建程序 GUI 的函数或方法；
    创建用户的类；
    以特定方式调用类构造函数的静态方法。
    一种创建型设计模式。
    
    当某人说到 “工厂” 这个词时， 其具体含义通常可以根据上下文来确定。 但如果你有疑问， 可以直接提问。 毕竟作者本人有时候也没有搞清楚。
    
### 2.构造方法